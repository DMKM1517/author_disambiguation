;"
clusterTest <- dbGetQuery(con, query_cluster_test)
clusterTest
clusterTest$computed_cluster
clusterTest$real_cluster
r = clusterTest$computed_cluster
s = clusterTest$real_cluster
pairsR <- getPairsOfClusters(r)
pairsR
pairsS <- getPairsOfClusters(s)
pairsS
Precision <- length(intersect(pairsR, pairsS)) / length(pairsR)
Precision
Recall <- length(intersect(pairsR, pairsS)) / length(pairsS)
Recall
F1 <- (2 * Precision * Recall) / (Precision + Recall)
F1
currentF1 <- pairwiseMetrics(clusterTest$computed_cluster, clusterTest$real_cluster)[1, 3]
currentF1
if(!is.na(currentF1) && currentF1 > bestF1){
bestF1 <- currentF1
bestCut <- i
bestCluster <- clusterTest
# print(paste(i , " - " , currentF1))
}
bestCluster
head(bestCluster, n=20)
# query_max_cluster <-"
# select case when max(cluster) is null then 0 else max(cluster) end as max_cluster
# from xref_authors_clusters;
# "
# df.max <- dbGetQuery(con, query_max_cluster)
# #Current max number of cluster
# df.max[1,1]
df.max <- as.matrix(0)
# distTable<- rf_distTable
# Reshapes the table into a wide format
distMatrix <- acast(distTable, formula = id1_d1 ~ id2_d2, fun.aggregate = mean, fill = 1)
# Create the Hierarchical Clustering
clusters <- hclust(as.dist(distMatrix), method = "complete")
#Values for the loop
bestModelCut <- NULL
bestCut <- 0
bestF1 <- 0
maxHeight <- max(clusters$height)
#Drops the temp table if exists
dbSendQuery(con, "drop table if exists main.temp_author_clusters;")
#Loop that looks for the best cut of the tree
for (i in seq(0, ceiling(maxHeight), by=0.05)) {
i <- 0.5
if(i>maxHeight)
break
cut <- as.data.frame(cutree(clusters, h = i))
# dbClusters <- cbind(str_split_fixed(row.names(cut), "-", n=2), (cut[,1] + df.max[1,1]))
dbClusters <- cbind(str_split_fixed(row.names(cut), "-", n=2), cut[,1] )
dbClusters <- as.data.frame(dbClusters, stringsAsFactors=FALSE)
colnames(dbClusters) <- c("id", "d", "cluster")
dbClusters$id <- as.numeric(dbClusters$id)
dbClusters$d <- as.numeric(dbClusters$d)
dbClusters$cluster <- as.numeric(dbClusters$cluster)
# str(dbClusters)
# head(dbClusters, n=30)
#Writes into the table
dbWriteTable(
con, c("main","temp_author_clusters"), value = dbClusters, append = TRUE, row.names = FALSE
)
# bring the real cluster
query_cluster_test <-
"select
c.id,
c.d,
ad.author_id as real_cluster,
c.cluster as computed_cluster
from
main.temp_author_clusters c
join main.authors_disambiguated ad on c.id = ad.id and c.d = ad.d
;"
clusterTest <- dbGetQuery(con, query_cluster_test)
currentF1 <- pairwiseMetrics(clusterTest$computed_cluster, clusterTest$real_cluster)[1, 3]
if(!is.na(currentF1) && currentF1 > bestF1){
bestF1 <- currentF1
bestCut <- i
bestCluster <- clusterTest
# print(paste(i , " - " , currentF1))
}
dbSendQuery(con, "truncate table main.temp_author_clusters;")
}
bestCluster
head(bestCluster, n=20)
rm(bestCluster)
#Drops the temp table if exists
dbSendQuery(con, "drop table if exists main.temp_author_clusters;")
#Loop that looks for the best cut of the tree
for (i in seq(0, ceiling(maxHeight), by=0.05)) {
i <- 0.5
if(i>maxHeight)
break
cut <- as.data.frame(cutree(clusters, h = i))
# dbClusters <- cbind(str_split_fixed(row.names(cut), "-", n=2), (cut[,1] + df.max[1,1]))
dbClusters <- cbind(str_split_fixed(row.names(cut), "-", n=2), cut[,1] )
dbClusters <- as.data.frame(dbClusters, stringsAsFactors=FALSE)
colnames(dbClusters) <- c("id", "d", "cluster")
dbClusters$id <- as.numeric(dbClusters$id)
dbClusters$d <- as.numeric(dbClusters$d)
dbClusters$cluster <- as.numeric(dbClusters$cluster)
# str(dbClusters)
# head(dbClusters, n=30)
#Writes into the table
dbWriteTable(
con, c("main","temp_author_clusters"), value = dbClusters, append = TRUE, row.names = FALSE
)
# bring the real cluster
query_cluster_test <-
"select
c.id,
c.d,
ad.author_id as real_cluster,
c.cluster as computed_cluster
from
main.temp_author_clusters c
join main.authors_disambiguated ad on c.id = ad.id and c.d = ad.d
;"
clusterTest <- dbGetQuery(con, query_cluster_test)
currentF1 <- pairwiseMetrics(clusterTest$computed_cluster, clusterTest$real_cluster)[1, 3]
if(!is.na(currentF1) && currentF1 > bestF1){
bestF1 <- currentF1
bestCut <- i
bestCluster <- clusterTest
# print(paste(i , " - " , currentF1))
}
dbSendQuery(con, "truncate table main.temp_author_clusters;")
}
head(bestCluster, n=20)
eiling(maxHeight)
ceiling(maxHeight)
maxHeight
# Function that calculates the clusters based on the distance table of the signatures
calculateClusters <- function(con, distTable) {
# query_max_cluster <-"
# select case when max(cluster) is null then 0 else max(cluster) end as max_cluster
# from xref_authors_clusters;
# "
# df.max <- dbGetQuery(con, query_max_cluster)
# #Current max number of cluster
# df.max[1,1]
df.max <- as.matrix(0)
# distTable<- rf_distTable
# Reshapes the table into a wide format
distMatrix <- acast(distTable, formula = id1_d1 ~ id2_d2, fun.aggregate = mean, fill = 1)
# Create the Hierarchical Clustering
clusters <- hclust(as.dist(distMatrix), method = "complete")
#Values for the loop
bestModelCut <- NULL
bestCut <- 0
bestF1 <- 0
maxHeight <- max(clusters$height)
#Drops the temp table if exists
dbSendQuery(con, "drop table if exists main.temp_author_clusters;")
#Loop that looks for the best cut of the tree
for (i in seq(0, ceiling(maxHeight), by=0.05)) {
i <- 0.5
cut <- as.data.frame(cutree(clusters, h = i))
# dbClusters <- cbind(str_split_fixed(row.names(cut), "-", n=2), (cut[,1] + df.max[1,1]))
dbClusters <- cbind(str_split_fixed(row.names(cut), "-", n=2), cut[,1] )
dbClusters <- as.data.frame(dbClusters, stringsAsFactors=FALSE)
colnames(dbClusters) <- c("id", "d", "cluster")
dbClusters$id <- as.numeric(dbClusters$id)
dbClusters$d <- as.numeric(dbClusters$d)
dbClusters$cluster <- as.numeric(dbClusters$cluster)
# str(dbClusters)
# head(dbClusters, n=30)
#Writes into the table
dbWriteTable(
con, c("main","temp_author_clusters"), value = dbClusters, append = TRUE, row.names = FALSE
)
# bring the real cluster
query_cluster_test <-
"select
c.id,
c.d,
ad.author_id as real_cluster,
c.cluster as computed_cluster
from
main.temp_author_clusters c
join main.authors_disambiguated ad on c.id = ad.id and c.d = ad.d
;"
clusterTest <- dbGetQuery(con, query_cluster_test)
currentF1 <- pairwiseMetrics(clusterTest$computed_cluster, clusterTest$real_cluster)[1, 3]
if(!is.na(currentF1) && currentF1 > bestF1){
bestF1 <- currentF1
bestCut <- i
bestCluster <- clusterTest
# print(paste(i , " - " , currentF1))
}
dbSendQuery(con, "truncate table main.temp_author_clusters;")
}
head(bestCluster, n=20)
#Drops the temp table
dbSendQuery(con, "drop table if exists main.temp_author_clusters;")
#Plot the best cluster cut
plot(clusters, cex=0.5)
abline(h = bestCut, lty = 2)
# Final Results
pairwiseResults <- cbind(BestCut = bestCut, Method = "Pairwise", pairwiseMetrics(bestCluster$computed_cluster, bestCluster$real_cluster))
b3Results <- cbind(BestCut = bestCut, Method = "B3", b3Metrics(bestCluster$computed_cluster, bestCluster$real_cluster))
rbind(pairwiseResults, b3Results)
}
rbind(
cbind(Model = 'RF', calculateClustersByFocusName(con, rf_distTable)),
cbind(Model = 'XGB', calculateClustersByFocusName(con, xgb_distTable)),
cbind(Model = 'SVM', calculateClustersByFocusName(con, svm_distTable)),
cbind(Model = 'CVGLM', calculateClustersByFocusName(con, cvglm_distTable))
)
library(R.utils)
# Function that performs a safe upsert into the DB
safeUpsert <- function(con, data, destTable, id_columns){
# data <- final_last_names
# destTable <- c('main', 'last_name_ethnicities')
# id_column <- 'last_name'
# id_columns <- c('id1', 'id2')
#sets the temp table
tempTable <- destTable
tempTable[length(tempTable)] <- paste(tempTable[length(tempTable)], ceiling(System$currentTimeMillis()), sep = "_")
dbWriteTable(con, tempTable, value = data, row.names = FALSE)
query_id_columns <- paste(id_columns, collapse = ", ")
query_equal_id_columns <- paste(paste('dest', id_columns, sep='.'), paste('temp', id_columns, sep='.'), sep='=', collapse = " AND ")
query_null_id_columns <- paste(paste('dest', id_columns, sep='.'), 'is null', sep=' ', collapse = " AND ")
query_dest_table <- paste(destTable, collapse = '.')
query_temp_table <- paste(tempTable, collapse = '.')
columns <- colnames(data)
query_columns <- paste(columns, collapse = ", ")
query_temp_columns <- paste('temp', columns, sep='.', collapse = ", ")
query_dest_columns <- paste('dest', columns, sep='.', collapse = ", ")
query_assign_columns <- paste(columns, paste('temp', columns, sep='.'), sep='=', collapse = ", ")
query_upsert <- "
CREATE INDEX ON :temp_table: (:id_columns:);
UPDATE :dest_table: AS dest
SET
:assign_columns:
FROM :temp_table: AS temp
WHERE :query_equal_id_columns:;
INSERT INTO :dest_table:
(:columns:)
SELECT
:temp_columns:
FROM
:dest_table: dest
right join :temp_table: temp on :query_equal_id_columns:
where
:null_id_columns:;
"
query_upsert <- str_replace_all(query_upsert, ":id_columns:", query_id_columns)
query_upsert <- str_replace_all(query_upsert, ":null_id_columns:", query_null_id_columns)
query_upsert <- str_replace_all(query_upsert, ":assign_columns:", query_assign_columns)
query_upsert <- str_replace_all(query_upsert, ":dest_table:", query_dest_table)
query_upsert <- str_replace_all(query_upsert, ":temp_table:", query_temp_table)
query_upsert <- str_replace_all(query_upsert, ":query_equal_id_columns:", query_equal_id_columns)
query_upsert <- str_replace_all(query_upsert, ":columns:", query_columns)
query_upsert <- str_replace_all(query_upsert, ":temp_columns:", query_temp_columns)
query_upsert <- str_replace_all(query_upsert, ":dest_column:", query_dest_columns)
# Execute the query
dbSendQuery(con, query_upsert)
#Drop the temp table
query_drop_temp <- str_replace_all("DROP TABLE IF EXISTS :temp_table:;", ":temp_table:", query_temp_table)
dbSendQuery(con, query_drop_temp)
}
# Function that calculates the clusters based on the distance table of the signatures
calculateClusters <- function(con, distTable, saveClusterInTable = NULL) {
# query_max_cluster <-"
# select case when max(cluster) is null then 0 else max(cluster) end as max_cluster
# from xref_authors_clusters;
# "
# df.max <- dbGetQuery(con, query_max_cluster)
# #Current max number of cluster
# df.max[1,1]
df.max <- as.matrix(0)
# distTable<- rf_distTable
# Reshapes the table into a wide format
distMatrix <- acast(distTable, formula = id1_d1 ~ id2_d2, fun.aggregate = mean, fill = 1)
# Create the Hierarchical Clustering
clusters <- hclust(as.dist(distMatrix), method = "complete")
#Values for the loop
bestModelCut <- NULL
bestCut <- 0
bestF1 <- 0
maxHeight <- max(clusters$height)
#Drops the temp table if exists
dbSendQuery(con, "drop table if exists main.temp_author_clusters;")
#Loop that looks for the best cut of the tree
for (i in seq(0, ceiling(maxHeight), by=0.05)) {
i <- 0.5
cut <- as.data.frame(cutree(clusters, h = i))
# dbClusters <- cbind(str_split_fixed(row.names(cut), "-", n=2), (cut[,1] + df.max[1,1]))
dbClusters <- cbind(str_split_fixed(row.names(cut), "-", n=2), cut[,1] )
dbClusters <- as.data.frame(dbClusters, stringsAsFactors=FALSE)
colnames(dbClusters) <- c("id", "d", "cluster")
dbClusters$id <- as.numeric(dbClusters$id)
dbClusters$d <- as.numeric(dbClusters$d)
dbClusters$cluster <- as.numeric(dbClusters$cluster)
# str(dbClusters)
# head(dbClusters, n=30)
#Writes into the table
dbWriteTable(
con, c("main","temp_author_clusters"), value = dbClusters, append = TRUE, row.names = FALSE
)
# bring the real cluster
query_cluster_test <-
"select
c.id,
c.d,
ad.author_id as real_cluster,
c.cluster as computed_cluster
from
main.temp_author_clusters c
join main.authors_disambiguated ad on c.id = ad.id and c.d = ad.d
;"
clusterTest <- dbGetQuery(con, query_cluster_test)
currentF1 <- pairwiseMetrics(clusterTest$computed_cluster, clusterTest$real_cluster)[1, 3]
if(!is.na(currentF1) && currentF1 > bestF1){
bestF1 <- currentF1
bestCut <- i
bestCluster <- clusterTest
# print(paste(i , " - " , currentF1))
}
dbSendQuery(con, "truncate table main.temp_author_clusters;")
}
head(bestCluster, n=20)
#Writes the best cluster if specified into the table
if(!is.null(saveClusterInTable)) {
dbWriteTable(
con, saveClusterInTable, value = dbClusters, append = TRUE, row.names = FALSE
)
}
#Drops the temp table
dbSendQuery(con, "drop table if exists main.temp_author_clusters;")
#Plot the best cluster cut
plot(clusters, cex=0.5)
abline(h = bestCut, lty = 2)
# Final Results
pairwiseResults <- cbind(BestCut = bestCut, Method = "Pairwise", pairwiseMetrics(bestCluster$computed_cluster, bestCluster$real_cluster))
b3Results <- cbind(BestCut = bestCut, Method = "B3", b3Metrics(bestCluster$computed_cluster, bestCluster$real_cluster))
rbind(pairwiseResults, b3Results)
}
distTable <- svm_distTable
#Truncates the temp table
dbSendQuery(con, "truncate table if exists main.temp_cluster_by_focus_name;")
uniqueLastNames <- unique(distTable$last_name)
for(i in 1:length(uniqueLastNames)){
# i<-9
current_last_name <- uniqueLastNames[i]
print(paste(i, '-', current_last_name , ' - ', nrow(distTable[distTable$last_name == current_last_name, ])))
if(nrow(distTable[distTable$last_name == current_last_name, ]) > 1){ #prevents from calculating from lonely signatures
calculateClusters(con, distTable[distTable$last_name == current_last_name, ], saveClusterInTable = c('main', 'temp_cluster_by_focus_name'))
}
}
# bring the real and calculated clusters
query_cluster_test <-
"select
c.id,
c.d,
ad.author_id as real_cluster,
c.cluster as computed_cluster
from
main.temp_cluster_by_focus_name c
join main.authors_disambiguated ad on c.id = ad.id and c.d = ad.d
;"
realCluster <- dbGetQuery(con, query_cluster_test)
realCluster
pairwiseResults <- cbind(BestCut = bestCut, Method = "Pairwise", pairwiseMetrics(bestCluster$computed_cluster, bestCluster$real_cluster))
b3Results <- cbind(BestCut = bestCut, Method = "B3", b3Metrics(bestCluster$computed_cluster, bestCluster$real_cluster))
rbind(pairwiseResults, b3Results)
realCluster
pairwiseResults <- cbind(BestCut = bestCut, Method = "Pairwise", pairwiseMetrics(realCluster$computed_cluster, realCluster$real_cluster))
b3Results <- cbind(BestCut = bestCut, Method = "B3", b3Metrics(realCluster$computed_cluster, realCluster$real_cluster))
rbind(pairwiseResults, b3Results)
# Function that calculates the clusters based on the distance table of the signatures
calculateClusters <- function(con, distTable, saveClusterInTable = NULL) {
if(!is.null(saveClusterInTable)){
query_max_cluster <-"
select case when max(cluster) is null then 0 else max(cluster) end as max_cluster
from :cluster_table:;
"
query_max_cluster <- str_replace_all(query_max_cluster, ":cluster_table:", paste(saveClusterInTable, collapse = '.'))
df.max <- dbGetQuery(con, query_max_cluster)
#Current max number of cluster
df.max[1,1]
}else{
df.max <- as.matrix(0)
}
# distTable<- rf_distTable
# Reshapes the table into a wide format
distMatrix <- acast(distTable, formula = id1_d1 ~ id2_d2, fun.aggregate = mean, fill = 1)
# Create the Hierarchical Clustering
clusters <- hclust(as.dist(distMatrix), method = "complete")
#Values for the loop
bestModelCut <- NULL
bestCut <- 0
bestF1 <- 0
maxHeight <- max(clusters$height)
#Drops the temp table if exists
dbSendQuery(con, "drop table if exists main.temp_author_clusters;")
#Loop that looks for the best cut of the tree
for (i in seq(0, ceiling(maxHeight), by=0.05)) {
i <- 0.5
cut <- as.data.frame(cutree(clusters, h = i))
# dbClusters <- cbind(str_split_fixed(row.names(cut), "-", n=2), (cut[,1] + df.max[1,1]))
dbClusters <- cbind(str_split_fixed(row.names(cut), "-", n=2), (cut[,1] + df.max[1,1]) )
dbClusters <- as.data.frame(dbClusters, stringsAsFactors=FALSE)
colnames(dbClusters) <- c("id", "d", "cluster")
dbClusters$id <- as.numeric(dbClusters$id)
dbClusters$d <- as.numeric(dbClusters$d)
dbClusters$cluster <- as.numeric(dbClusters$cluster)
# str(dbClusters)
# head(dbClusters, n=30)
#Writes into the table
dbWriteTable(
con, c("main","temp_author_clusters"), value = dbClusters, append = TRUE, row.names = FALSE
)
# bring the real cluster
query_cluster_test <-
"select
c.id,
c.d,
ad.author_id as real_cluster,
c.cluster as computed_cluster
from
main.temp_author_clusters c
join main.authors_disambiguated ad on c.id = ad.id and c.d = ad.d
;"
clusterTest <- dbGetQuery(con, query_cluster_test)
currentF1 <- pairwiseMetrics(clusterTest$computed_cluster, clusterTest$real_cluster)[1, 3]
if(!is.na(currentF1) && currentF1 > bestF1){
bestF1 <- currentF1
bestCut <- i
bestCluster <- clusterTest
# print(paste(i , " - " , currentF1))
}
dbSendQuery(con, "truncate table main.temp_author_clusters;")
}
head(bestCluster, n=20)
#Writes the best cluster if specified into the table
if(!is.null(saveClusterInTable)) {
dbWriteTable(
con, saveClusterInTable, value = dbClusters, append = TRUE, row.names = FALSE
)
}
#Drops the temp table
dbSendQuery(con, "drop table if exists main.temp_author_clusters;")
#Plot the best cluster cut
plot(clusters, cex=0.5)
abline(h = bestCut, lty = 2)
# Final Results
pairwiseResults <- cbind(BestCut = bestCut, Method = "Pairwise", pairwiseMetrics(bestCluster$computed_cluster, bestCluster$real_cluster))
b3Results <- cbind(BestCut = bestCut, Method = "B3", b3Metrics(bestCluster$computed_cluster, bestCluster$real_cluster))
rbind(pairwiseResults, b3Results)
}
dbSendQuery(con, "truncate if exists main.temp_cluster_by_focus_name;")
uniqueLastNames <- unique(distTable$last_name)
for(i in 1:length(uniqueLastNames)){
# i<-9
current_last_name <- uniqueLastNames[i]
print(paste(i, '-', current_last_name , ' - ', nrow(distTable[distTable$last_name == current_last_name, ])))
if(nrow(distTable[distTable$last_name == current_last_name, ]) > 1){ #prevents from calculating from lonely signatures
calculateClusters(con, distTable[distTable$last_name == current_last_name, ], saveClusterInTable = c('main', 'temp_cluster_by_focus_name'))
}
}
# bring the real and calculated clusters
query_cluster_test <-
"select
c.id,
c.d,
ad.author_id as real_cluster,
c.cluster as computed_cluster
from
main.temp_cluster_by_focus_name c
join main.authors_disambiguated ad on c.id = ad.id and c.d = ad.d
;"
realCluster <- dbGetQuery(con, query_cluster_test)
pairwiseResults <- cbind(BestCut = bestCut, Method = "Pairwise", pairwiseMetrics(realCluster$computed_cluster, realCluster$real_cluster))
b3Results <- cbind(BestCut = bestCut, Method = "B3", b3Metrics(realCluster$computed_cluster, realCluster$real_cluster))
rbind(pairwiseResults, b3Results)
realCluster
dbSendQuery(con, "truncate table main.temp_cluster_by_focus_name;")
uniqueLastNames <- unique(distTable$last_name)
for(i in 1:length(uniqueLastNames)){
# i<-9
current_last_name <- uniqueLastNames[i]
print(paste(i, '-', current_last_name , ' - ', nrow(distTable[distTable$last_name == current_last_name, ])))
if(nrow(distTable[distTable$last_name == current_last_name, ]) > 1){ #prevents from calculating from lonely signatures
calculateClusters(con, distTable[distTable$last_name == current_last_name, ], saveClusterInTable = c('main', 'temp_cluster_by_focus_name'))
}
}
# bring the real and calculated clusters
query_cluster_test <-
"select
c.id,
c.d,
ad.author_id as real_cluster,
c.cluster as computed_cluster
from
main.temp_cluster_by_focus_name c
join main.authors_disambiguated ad on c.id = ad.id and c.d = ad.d
;"
realCluster <- dbGetQuery(con, query_cluster_test)
#Drops the temp table
dbSendQuery(con, "drop table if exists main.temp_cluster_by_focus_name;")
# Final Results
pairwiseResults <- cbind(BestCut = bestCut, Method = "Pairwise", pairwiseMetrics(realCluster$computed_cluster, realCluster$real_cluster))
b3Results <- cbind(BestCut = bestCut, Method = "B3", b3Metrics(realCluster$computed_cluster, realCluster$real_cluster))
rbind(pairwiseResults, b3Results)
version()
R.version
